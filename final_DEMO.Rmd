---
title: "final_DEMO"
output: html_document
date: "2024-06-13"
---

```{r message=FALSE, warning=FALSE}
library(e1071)
library(jpeg)
library(ROCR)
library(caret)
library(imager)
library(gplots)
library(readxl)
library(ggplot2)
library(reshape2)
library(readbitmap)
```

從圖像中提取出RGB的平均數、變異數和一階差分值，並進行歸一化，編寫成csv檔輸出。

```{r}
compute_diff <- function(img) {
  diff_r <- abs(diff(img[,,1]))
  diff_g <- abs(diff(img[,,2]))
  diff_b <- abs(diff(img[,,3]))
  c(mean(diff_r), mean(diff_g), mean(diff_b))
}

folder_paths <- c("final_jpeg_data/train/drawings", "final_jpeg_data/train/engraving",
                  "final_jpeg_data/train/iconography", "final_jpeg_data/train/sculpture")

train_data <- matrix(nrow = 2000, ncol = 10)
i <- 1

for (label in folder_paths) {
  image_files <- list.files(path = label, pattern = ".jpeg", full.names = TRUE)
  for (image_file in image_files) {
    img <- readJPEG(image_file)
    
    train_data[i, 1:3] <- compute_diff(img) 
    train_data[i, 4:6] <- c(mean(img[,,1]), mean(img[,,2]), mean(img[,,3]))
    train_data[i, 7:9] <- c(var(c(img[,,1])), var(c(img[,,2])), var(c(img[,,3])))
    train_data[i, 10] <- label
    i = i + 1
  }
}

folder_paths <- c("final_jpeg_data/test/drawings", "final_jpeg_data/test/engraving",
                  "final_jpeg_data/test/iconography", "final_jpeg_data/test/sculpture")

test_data <- matrix(nrow = 200, ncol = 10) 
i <- 1

for (label in folder_paths) {
  image_files <- list.files(path = label, pattern = ".jpeg", full.names = TRUE)
  for (image_file in image_files) {
    img <- readJPEG(image_file)
    
    test_data[i, 1:3] <- compute_diff(img) 
    test_data[i, 4:6] <- c(mean(img[,,1]), mean(img[,,2]), mean(img[,,3])) 
    test_data[i, 7:9] <- c(var(c(img[,,1])), var(c(img[,,2])), var(c(img[,,3])))
    test_data[i, 10] <- label
    i = i + 1
  }
}

train_data <- data.frame(train_data)
train_x <- train_data[, 1:9] 
train_x$X1 <- as.numeric(train_x$X1)
train_x$X2 <- as.numeric(train_x$X2)
train_x$X3 <- as.numeric(train_x$X3)
train_x$X4 <- as.numeric(train_x$X4)
train_x$X5 <- as.numeric(train_x$X5)
train_x$X6 <- as.numeric(train_x$X6)
train_x$X7 <- as.numeric(train_x$X7)
train_x$X8 <- as.numeric(train_x$X8)
train_x$X9 <- as.numeric(train_x$X9)
train_y <- as.factor(train_data$X10)

test_data <- data.frame(test_data)
test_x <- test_data[, 1:9] 
test_x$X1 <- as.numeric(test_x$X1)
test_x$X2 <- as.numeric(test_x$X2)
test_x$X3 <- as.numeric(test_x$X3)
test_x$X4 <- as.numeric(test_x$X4)
test_x$X5 <- as.numeric(test_x$X5)
test_x$X6 <- as.numeric(test_x$X6)
test_x$X7 <- as.numeric(test_x$X7)
test_x$X8 <- as.numeric(test_x$X8)
test_x$X9 <- as.numeric(test_x$X9)
test_y <- as.factor(test_data$X10)

train_data$X10 <- gsub("final_jpeg_data/train/", "", train_data$X10)
test_data$X10 <- gsub("final_jpeg_data/test/", "", test_data$X10)

colnames(train_data) <- c("r_diff", "g_diff", "b_diff", "r_mean", "g_mean", "b_mean", "r_var", "g_var", "b_var", "label")
colnames(test_data) <- c("r_diff", "g_diff", "b_diff", "r_mean", "g_mean", "b_mean", "r_var", "g_var", "b_var", "label")

write.csv(train_data, "train_mean_var_diff.csv", row.names = FALSE)
write.csv(test_data, "test_mean_var_diff.csv", row.names = FALSE)
```

將提取出來的9種顏色特徵，繪製成直方圖。

```{r}
training_data <- read.csv("train_mean_var_diff.csv")
features <- c("r_mean", "g_mean", "b_mean", "r_var", "g_var", "b_var", "r_diff", "g_diff", "b_diff")

# 根據特徵和類別劃分數據
melted_data <- melt(training_data, id.vars = "label")
# 篩選出包含指定特徵的數據
melted_data <- melted_data[melted_data$variable %in% features, ]

# 繪製箱線圖
boxplot <- ggplot(melted_data, aes(x = variable, y = value, fill = label)) +
  geom_boxplot(alpha = 0.5, outlier.shape =  "*") +
  labs(title = "Boxplot of Color Features: 4 label",
       x = "Features",
       y = "Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(hjust = 1)) +
  scale_fill_manual(values = c("drawings" = "#7070db", 
                               "engraving" = "#ff704d", 
                               "iconography" = "#59b300",
                               "sculpture" = "#ff66a3")) +
  theme(plot.title = element_text(hjust = 0.5),
        legend.position = "bottom") +
  guides(fill = guide_legend(title = "Label"))
print(boxplot)
```


讀取各項提取後的特徵，將研究過後的最佳特徵組合進行整併。

```{r}
data1 <- read.csv("train_mean_var_diff.csv")
data2 <- read.csv("train_structure.csv")
data5 <- read.csv("train_texture.csv")
data7 <- read_excel("(train) shape_features_normalized.xlsx")

train_data <- cbind(data1, data2[, -4], data5[, -c(4, 5)], data7[, -c(1, 2, 3, 4, 5, 6, 7)])

data3 <- read.csv("test_mean_var_diff.csv")
data4 <- read.csv("test_structure.csv")
data6 <- read.csv("test_texture.csv")
data8 <- read_excel("(test) shape_features_normalized.xlsx")

test_data <- cbind(data3, data4[, -4], data6[, -c(4, 5)], data8[, -c(1, 2, 3, 4, 5, 6, 7)])
train_label <- as.factor(train_data$label)
test_label <- as.factor(test_data$label)
```

使用我們的最佳SVM模型，cost設置為4，gamma設置為0.2，最終測試準確率為0.77。

```{r}
svm_model <- svm(train_label ~ ., data = train_data[, -10], kernel = "radial", 
                 cost = 4, gamma = 0.2)
y_pred <- predict(svm_model, test_data[, -10])
accuracy <- mean(y_pred == test_label)

print(paste("Test Accuracy:", accuracy))
```

測試集的混淆矩陣，從對角線可以看出大部分畫作得到正確分類，但在分類drawings跟engraving有些許困難。

```{r}
conf_matrix <- table(test_label, y_pred)
colorPalette <- colorRampPalette(c("white", "#4682B4"))(200)

heatmap.2(conf_matrix, 
          trace = "none",          
          col = colorPalette,      
          dendrogram = "none",     
          main = "Confusion Matrix",  
          xlab = "Predicted",      
          ylab = "Actual",         
          margins = c(5, 10),      
          cellnote = conf_matrix,  
          notecol = "black",       
          density.info = "none",   
          key = TRUE,              
          keysize = 1.5,
          cexRow = 0.8,            
          cexCol = 0.8,
          cex.axis = 0.9,
          key.title = NA)        
```

訓練準確率為0.882。

```{r}
y_pred <- predict(svm_model, train_data[, -10])
accuracy <- mean(y_pred == train_label)

print(paste("Train Accuracy:", accuracy))
```

訓練集的混淆矩陣。

```{r}
conf_matrix <- table(train_label, y_pred)
colorPalette <- colorRampPalette(c("white", "#4682B4"))(200)

heatmap.2(conf_matrix, 
          trace = "none",          
          col = colorPalette,      
          dendrogram = "none",     
          main = "Confusion Matrix",  
          xlab = "Predicted",      
          ylab = "Actual",         
          margins = c(5, 10),      
          cellnote = conf_matrix,  
          notecol = "black",       
          density.info = "none",   
          key = TRUE,              
          keysize = 1.5,
          cexRow = 0.8,            
          cexCol = 0.8,
          cex.axis = 0.9,
          key.title = NA) 
```

計算圖像結構特徵(layers, symmetry, alignment)，並保存到CSV文件。 

```{r}
compute_structure_features <- function(image_path) {
  
  img <- load.image(image_path)
  # 分層結構特徵（色彩分佈總和）
  layers <- sum(colMeans(colSums(as.array(img))))
  
  # 圖像轉換為灰度
  gray_img <- grayscale(img)
  # 圖像的水平投影
  horizontal_profile <- colMeans(as.matrix(gray_img))
  # 圖像的對稱性
  symmetry <- sum(abs(horizontal_profile - rev(horizontal_profile))) / length(horizontal_profile)
  
  # 灰階影像的協方差矩陣
  cov_matrix <- cov(as.matrix(gray_img))
  # 協方差矩陣的特徵值和特徵向量
  eigenvalues <- eigen(cov_matrix)$values
  eigenvectors <- eigen(cov_matrix)$vectors
  # 提取主特徵向量（對應最大特徵值）
  main_eigenvector <- eigenvectors[, which.max(eigenvalues)]
  # 主特徵向量與水平方向的夾角（對齊度）
  alignment <- abs(atan(main_eigenvector[2] / main_eigenvector[1]))
  
  return(c(layers, symmetry, alignment))
}

# 訓練集
training_paths <- list.files("final_jpeg_data/train/", recursive = TRUE, full.names = TRUE)
training_structure_features <- t(sapply(training_paths, compute_structure_features))

# 驗證集 (測試集)
validation_paths <- list.files("final_jpeg_data/test/", recursive = TRUE, full.names = TRUE)
validation_structure_features <- t(sapply(validation_paths, compute_structure_features))

# 結果轉換為數據框
training_df <- data.frame(training_structure_features)
names(training_df) <- c("layers", "symmetry", "alignment")
training_df$label <- gsub("final_jpeg_data/train/", "", dirname(training_paths))

validation_df <- data.frame(validation_structure_features)
names(validation_df) <- c("layers", "symmetry", "alignment")
validation_df$label <- gsub("final_jpeg_data/test/", "", dirname(validation_paths))

# 缺失值替換為平均值
numeric_cols <- sapply(training_df, is.numeric)
for (col in names(training_df)[numeric_cols]) {
  training_df[is.na(training_df[, col]), col] <- mean(training_df[, col], na.rm = TRUE)
}
for (col in names(validation_df)[numeric_cols]) {
  validation_df[is.na(validation_df[, col]), col] <- mean(validation_df[, col], na.rm = TRUE)
}

# 數值正規化[0,1](Normalization)/標準化(Standardization)
for (col in names(training_df)[numeric_cols]) {
  training_df[, col] <- scale(training_df[, col], center = FALSE, scale = max(abs(training_df[, col]))) # Normalization
  # training_df[, col] <- scale(training_df[, col], center = TRUE, scale = TRUE) # Standardization
}
for (col in names(validation_df)[numeric_cols]) {
  validation_df[, col] <- scale(validation_df[, col], center = FALSE, scale = max(abs(validation_df[, col]))) # Normalization
  # validation_df[, col] <- scale(validation_df[, col], center = TRUE, scale = TRUE) # Standardization
}

# 保存到CSV文件
write.csv(training_df, "train_structure.csv", row.names = FALSE)
write.csv(validation_df, "test_structure.csv", row.names = FALSE)
```

將圖像結構特徵，繪製成 box plot。

```{r}
library(ggplot2)
library(reshape2)

training_data <- read.csv("train_structure.csv")
features <- c("layers", "symmetry", "alignment")

# 根據特徵和類別劃分數據
melted_data <- melt(training_data, id.vars = "label")
# 篩選出包含指定特徵的數據
melted_data <- melted_data[melted_data$variable %in% features, ]

# 繪製箱線圖
boxplot <- ggplot(melted_data, aes(x = variable, y = value, fill = label)) +
  geom_boxplot(alpha = 0.5, outlier.shape =  "*") +
  labs(title = "Boxplot of Structure Features: 4 label",
       x = "Features",
       y = "Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(hjust = 1)) +
  scale_fill_manual(values = c("drawings" = "#7070db", 
                               "engraving" = "#ff704d", 
                               "iconography" = "#59b300",
                               "sculpture" = "#ff66a3")) +
  theme(plot.title = element_text(hjust = 0.5),
        legend.position = "bottom") +
  guides(fill = guide_legend(title = "Label"))
print(boxplot)
```
